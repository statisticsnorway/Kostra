% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LmImpute.r
\encoding{UTF8}
\name{LmImpute}
\alias{LmImpute}
\title{INTERNAL FUNCTION: Regeression imputation.}
\usage{
LmImpute(
  data,
  model = "y~x",
  weights = NULL,
  limitModel = 2.5,
  limitIterate = 4.5,
  limitImpute = 50,
  maxiter = 10,
  returnIter = TRUE,
  returnYHat = FALSE,
  returnFirst = FALSE,
  returnLast = TRUE,
  returnFinal = FALSE,
  MultiFuction = function(x) {
     max(abs(x))
 },
  estimationGroup = TRUE,
  unfoldCoef = FALSE,
  category123 = NULL,
  forceCategory2 = rep(FALSE, N),
  BackTransform = NULL,
  warningEstimate = "estimate: Missing yImputed replaced by zero",
  removeEmpty = FALSE,
  NArStudHandling = warning,
  cvPercent = TRUE,
  returnSameType = FALSE
)
}
\arguments{
\item{data}{Input data set (data.frame, data.table or list)}

\item{model}{String with model formula}

\item{weights}{NULL or string with weight expression}

\item{limitModel}{Studentized residuals limit. Above limit -> category 2.}

\item{limitIterate}{Studentized residuals limit for iterative calculation of studentized residuals.}

\item{limitImpute}{Studentized residuals limit. Above limit -> category 3. No imputation when 0.}

\item{maxiter}{Maximum number of iterations.}

\item{returnIter}{When TRUE, iteration when observation was thrown outin output.}

\item{returnYHat}{When TRUE, fitted values and corresponding estimates in output.}

\item{returnFirst}{When TRUE, studentized residuals from first iteration in output.}

\item{returnLast}{When TRUE, some results from last iteration in output.}

\item{returnFinal}{When TRUE, extra results from final model in output.}

\item{MultiFuction}{Transforming rStud for several responses into a single positive value.}

\item{estimationGroup}{Total estimates will be be computed within each group. Default (and TRUE) is a single group (estimationGroup <- rep(1, N) ).}

\item{unfoldCoef}{When TRUE several elements of coef will be spilt as several ouput elements.
unfoldCoef=2 is a specialised variant used to ensure two coefficients in output (extra coefficient zero).}

\item{category123}{When non-NULL, this is used directly with no iteration.}

\item{forceCategory2}{Force category 2 (can be useful for elements imputed by another method)}

\item{BackTransform}{When model contains transformation of y (e.g: "log(y)~x") a function (e.g: exp) can be supplied to transform back
to original scale before calculation of leaveOutResid, yHat, yImputed, estimate, estimateYHat, estimateOrig and seRobust.}

\item{warningEstimate}{Warning text when missing values. Use NULL to avoid warning.}

\item{removeEmpty}{When TRUE empty elements will be removed from output.}

\item{NArStudHandling}{Function (warning or stop) taking a message as input. Used when rStud in model (category 1) is missing.}

\item{cvPercent}{When TRUE (default) cv output is in percent}

\item{returnSameType}{When TRUE and when the type of input y variable(s) is integer, the output type of yImputed
and estimate is also integer. Estimates/sums are then calculated from rounded imputed values.}
}
\value{
A list with separate elements. Each element can be a scalar, vector or a matrix.
Possible elements are:
   \item{x}{The input x variable}
   \item{y}{The input y variable}
   \item{strata}{The input strata variable}
   \item{category123}{The three imputation groups: representative (1), correct but not representative (2), wrong (3) and zero
   when x is missing.}
   \item{yHat}{Fitted values}
   \item{yImputed}{Imputed y-data}
   \item{rStudFirst}{Initial studentized residuals}
   \item{rStud}{The final (or last) studentized residuals}
   \item{dffits}{The final (or last) DFFITS statistic}
   \item{hii}{The final (or last) leverages (diagonal elements of hat matrix)}
   \item{leaveOutResid}{The final (or last) outside-model residual}
   \item{iter}{Iteration when observation was thrown out}
   \item{N}{Total number of observations (rows in data)}
   \item{nImputed}{Number of imputed observations}
   \item{estimate}{Totale estimate from imputed data}
   \item{cv}{Coefficient of variation = seEstimate/estimate. In percent when cvPercent=TRUE (default)}
   \item{estimateYhat}{Totale estimate based on model fits}
   \item{estimateOrig}{Estimate based on original data with missing set to zero}
   \item{coef}{The final (or last) model coefficient(s). Several variables when several parameters ("coef..Intercept.", "coef.x").}
   \item{nModel}{The final (or last) number of observations in model.}
   \item{sigmaFirst}{Initial square root of the estimated variance parameter}
   \item{sigmaHat}{The final (or last)  square root of the estimated variance parameter}
   \item{seEstimate}{The final (or last) standard error estimate of the total estimate from imputed data}
   \item{seRobust}{Robust variant of seEstimate (experimental)}
}
\description{
Imputation by weighted regeression, using lm, allowing multiple explanatory
variables and multiple response variables.
Impute missing and wrong values (category 3) by the model based on representative data (category 1).
Some data are considered correct but not representative (category 2).
}
\examples{
z = data.frame(  # Same example as in Thorud et.al (2010).
        x = c(1.1, 2.2, 3.3, 4.4, 5.5),
        y = c(2.3, 3.1, 3.2, 3.7, 4.5))
LmImpute(z)  # Simple regression
LmImpute(z, model = "y~x-1", weights = "1/x")  # Ratio model

rateData <- KostraData("rateData")               # Real Kostra data set
w <- rateData$data[, c(16, 5, 14, 15, 19)]
w <- w[is.finite(w[,"Ny.kostragruppe"]), ]       # Remove Longyearbyen
w[w[,"Ny.kostragruppe"]>13,"Ny.kostragruppe"]=13 # Combine small strata
names(w) = c("x", "y", "y14", "y15", "k")

# Ratio model within each strata assumming common variance
LmImpute(w, "y~x:factor(k)-1", weights = "1/x", estimationGroup = w$k)

# Similar to above, but two y variables
LmImpute(w, "cbind(y14,y15)~x:factor(k)-1", weights = "1/x", estimationGroup = w$k)

# Using transformation and "BackTransform"
LmImpute(w, "sqrt(y)~x",BackTransform = function(x) x^2,returnYHat = TRUE)

# Direct imputation of x
LmImpute(w, "I(y-x)~0",weights = "1/x",
  BackTransform = function(y){return(y+dynGet("data")$x)},
  limitModel = Inf, limitIterate = Inf, limitImpute = Inf,
  returnYHat = TRUE)



}
\keyword{intern}
