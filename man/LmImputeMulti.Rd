% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LmImpute2.R
\encoding{UTF8}
\name{LmImputeMulti}
\alias{LmImputeMulti}
\alias{LmImpute2}
\alias{LmImputeOne2Many}
\title{INTERNAL FUNCTION: Repeated regression imputation.}
\usage{
LmImputeMulti(
  data,
  yName = "y",
  xModel = c("x1", "x2"),
  yModel = yName,
  weights = NULL,
  limitModel = 2.5,
  limitIterate = 4.5,
  limitImpute = 50,
  maxiter = 10,
  returnIter = TRUE,
  returnYHat = FALSE,
  returnFirst = FALSE,
  returnLast = TRUE,
  returnFinal = FALSE,
  MultiFuction = function(x) {
     max(abs(x))
 },
  estimationGroup = TRUE,
  unfoldCoef = FALSE,
  BackTransform = list(NULL),
  warningEstimate = vector("list", n),
  removeEmpty = FALSE,
  replaceByImputed = TRUE,
  imputedInModel = FALSE,
  category123FromFirst = FALSE,
  cvPercent = TRUE,
  returnSameType = FALSE
)

LmImpute2(
  data,
  warningEstimate = list(NULL, "estimate: Missing yImputed replaced by zero"),
  replaceByImputed = TRUE,
  cvPercent = TRUE,
  ...
)

LmImputeOne2Many(
  data,
  yName = "y",
  xModel = "x",
  yModel = c(yName, "yMany"),
  category123FromFirst = TRUE,
  keepSinge = NULL,
  keepMulti = NULL,
  ...
)
}
\arguments{
\item{data}{Input data set (data.frame, data.table or list)}

\item{yName}{Name of interest variable in data set}

\item{xModel}{Vector of strings with the right part model formula.}

\item{yModel}{String with left part model formula  (vector possible)}

\item{weights}{NULL or string with weight expression  (vector possible)}

\item{limitModel}{Studentized residuals limit. Above limit -> category 2.(vector possible)}

\item{limitIterate}{Studentized residuals limit for iterative calculation of studentized residuals.(vector possible)}

\item{limitImpute}{Studentized residuals limit. Above limit -> category 3. No imputation when 0.(vector possible)}

\item{maxiter}{Maximum number of iterations.(vector possible)}

\item{returnIter}{When TRUE, iteration when observation was thrown outin output.(vector possible)}

\item{returnYHat}{When TRUE, fitted values and corresponding estimates in output. (vector possible)}

\item{returnFirst}{When TRUE, studentized residuals from first iteration in output. (vector possible)}

\item{returnLast}{When TRUE, some results from last iteration in output.(vector possible)}

\item{returnFinal}{When TRUE, extra results from final model in output. (vector possible)}

\item{MultiFuction}{Transforming rStud for several responses into a single positive value.}

\item{estimationGroup}{Total estimates will be computed within each group. Default (and TRUE) is a single group (estimationGroup <- rep(1, N) ).}

\item{unfoldCoef}{When TRUE several elements of coef will be spilt as several ouput elements.}

\item{BackTransform}{When model contains transformation of y (e.g: "log(y)~x") a function (e.g: exp) can be supplied to transform back
to original scale before calculation of leaveOutResid, yHat, yImputed, estimate, estimateYHat, estimateOrig and seRobust.
(list possible)}

\item{warningEstimate}{Warning text when missing values. Use NULL to avoid warning. (list possible)}

\item{removeEmpty}{When TRUE empty elements will be removed from output.}

\item{replaceByImputed}{When TRUE missing values of the interest variable (y) is replaced by imputed values in each round.}

\item{imputedInModel}{When FALSE above imputed values are omitted from subsequent models (category 2 forced).}

\item{category123FromFirst}{Whene TRUE category123 from first run is input to subsequent LmImpute calls.}

\item{cvPercent}{When TRUE (default) cv output is in percent}

\item{returnSameType}{When TRUE and when the type of input y variable(s) is integer, the output type of yImputed
and estimate is also integer. Estimates/sums are then calculated from rounded imputed values.}

\item{keepSinge}{When non-NULL only output elements with names in keepSinge are kept from first LmImputeOne2Many run.}

\item{keepMulti}{When non-NULL only output elements with names in keepMulti are kept from second LmImputeOne2Many run.}
}
\value{
Output of LmImputeMulti is a list where each element is the output of \code{\link{LmImpute}}.
        Output of LmImpute2 is not such a list. Instead the names are changed using "A" and "B".
        Output of LmImputeOne2Many is not such a list. Instead the names from second round are changed using "M".
}
\description{
LmImpute is run several times using different versions of input parameters. Output from each run of
LmImpute is in output of this function. In each run it is possible to update the interest variable (y)
with available imputed values. Thus the function can be used to impute using a primary x-variable and
a secondary x-variable for cases where the primary is missing.
}
\details{
LmImputeMulti performs several calls to LmImpute and the number of calls is the length of xModel.
         Other parameters can also change between calls by specifying them as vectors or lists.

         LmImpute2 is a specialized variant for two LmImpute runs only
         and combined estimates of seRobust, seEStimate and cv are calculated when replaceByImputed = TRUE.

         LmImputeOne2Many is another specialized variant meant for two runs using the same model except
         that the first run has a single y and the next run several y's. Category123 from the first run is used in the second.
}
\examples{

# -----  LmImpute2 and LmImputeMulti -----
set.seed(123)  # same results each time
z = data.frame(  # Small test data set
x1 = c(NA,2:19,NA),
x2 = rep(1:20),
y = runif(20)+c(rep(0,15),NA,1E3,1E5,NA,NA))
LmImpute2(z)
LmImputeMulti(z)
LmImputeMulti(z,xModel=c("x1","x2","x2"),limitImpute=c(50,50,3), replaceByImputed=FALSE)


 # -----  LmImputeOne2Many -----
 # Create data fram z with matrix embedded in one variable
 # The single y is also the first variable in the matrix yMany
 set.seed(123)  # same results each time
 y = runif(20)+c(rep(0,15),NA,1E3,1E5,NA,NA)
 z = data.frame(  # Small test data set
   x = c(1,1,1:10,3,3,3,4,4,5,5,5),
   y = y,
   yMany = I(cbind(y,matrix(1:60,20,3,dimnames=list(NULL,c("A","B","C"))))))
 a=LmImputeOne2Many(z,limitModel=1)
 print(a)
 a$MrStud[, 1] -  a$rStud # Not equal since no iteration and no "last" when multiple y
 a=LmImputeOne2Many(z,limitModel=1,returnFinal=TRUE)
 a$MrStud[, 1] -  a$rStud # Now equal



}
\keyword{intern}
